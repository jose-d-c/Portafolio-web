// Programa 21: Quicksort en Java con vector de 7 enteros
// Objetivo:
// Ordenar un vector de enteros en forma ascendente usando Quicksort.
//
// Idea general del algoritmo:
// 1) Elegir un pivote.
// 2) Reubicar los elementos menores o iguales al pivote a su izquierda,
//    y los mayores a su derecha (particion).
// 3) Repetir el proceso de manera recursiva en ambos lados.
//
// En este ejemplo:
// - Se usa como pivote el ultimo elemento del tramo actual.
// - El vector de entrada tiene 7 datos enteros.
// - Traza esperada del primer particionado (con pivote 14):
//   Inicio: [34, 7, 23, 32, 5, 62, 14]
//   Tras recorrer y ubicar <= pivote: [7, 5, 23, 32, 34, 62, 14]
//   Colocando pivote en su posicion final: [7, 5, 14, 32, 34, 62, 23]

public class Programa21QuickSort {

    public static void main(String[] args) {
        // Vector de entrada con 7 enteros (input solicitado).
        int[] datos = {34, 7, 23, 32, 5, 62, 14};

        // Mostrar vector antes de ordenar.
        System.out.print("Vector original: ");
        imprimirVector(datos);

        // Llamada inicial a Quicksort sobre todo el vector.
        quickSort(datos, 0, datos.length - 1);

        // Mostrar vector ya ordenado.
        System.out.print("Vector ordenado: ");
        imprimirVector(datos);
    }

    // Metodo recursivo de Quicksort.
    // izquierda y derecha delimitan el subarreglo que se va a ordenar.
    public static void quickSort(int[] arreglo, int izquierda, int derecha) {
        // Caso base: si el tramo tiene 0 o 1 elementos, ya esta ordenado.
        if (izquierda >= derecha) {
            return;
        }

        // Particionar y obtener la posicion final del pivote.
        int indicePivote = particionar(arreglo, izquierda, derecha);

        // Ordenar recursivamente la parte izquierda del pivote.
        quickSort(arreglo, izquierda, indicePivote - 1);

        // Ordenar recursivamente la parte derecha del pivote.
        quickSort(arreglo, indicePivote + 1, derecha);
    }

    // Reordena el tramo [izquierda, derecha] respecto al pivote.
    // Retorna el indice donde queda el pivote al finalizar.
    public static int particionar(int[] arreglo, int izquierda, int derecha) {
        int pivote = arreglo[derecha]; // Elegimos el ultimo elemento como pivote.
        int i = izquierda - 1; // Marca el final de la zona de <= pivote.

        // Recorremos desde izquierda hasta derecha - 1.
        for (int j = izquierda; j < derecha; j++) {
            // Si el elemento actual es menor o igual que el pivote,
            // lo llevamos a la zona izquierda.
            if (arreglo[j] <= pivote) {
                i++;
                intercambiar(arreglo, i, j);
            }
        }

        // Colocar el pivote justo despues de la zona de menores/iguales.
        intercambiar(arreglo, i + 1, derecha);

        // Retornar posicion final del pivote.
        return i + 1;
    }

    // Intercambia dos posiciones del arreglo.
    public static void intercambiar(int[] arreglo, int a, int b) {
        int temporal = arreglo[a];
        arreglo[a] = arreglo[b];
        arreglo[b] = temporal;
    }

    // Metodo auxiliar para imprimir el vector en formato [x, y, z].
    public static void imprimirVector(int[] arreglo) {
        System.out.print("[");
        for (int i = 0; i < arreglo.length; i++) {
            System.out.print(arreglo[i]);
            if (i < arreglo.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
}
