// Programa 27: Medicion de MEMORIA en 3 escenarios (bajo, medio, muchos datos)
// ------------------------------------------------------------------------------
// Este programa compara consumo de memoria de:
// Burbuja simple, Burbuja mejorado, Quicksort, Shell Sort y Seleccion.
//
// Escenarios:
// 1) Datos bajos
// 2) Datos medios
// 3) Muchos datos
//
// Se muestra paso a paso por algoritmo y, en cada paso mostrado,
// se reporta delta de memoria respecto al inicio de ese algoritmo.
// Nota: En Java la memoria es aproximada (GC), pero es util para comparar.

import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;

public class Programa27MemoriaComparativa {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.println("=== MEDICION DE MEMORIA (3 ESCENARIOS) ===");
        System.out.println("Tipo de dato: 1) Enteros  2) String");
        System.out.print("Opcion: ");
        int tipo = sc.nextInt();

        System.out.print("Cantidad para datos bajos: ");
        int nBajo = sc.nextInt();
        System.out.print("Cantidad para datos medios: ");
        int nMedio = sc.nextInt();
        System.out.print("Cantidad para muchos datos: ");
        int nAlto = sc.nextInt();

        System.out.print("Semilla aleatoria: ");
        long semilla = sc.nextLong();

        if (tipo == 1) {
            ejecutarEscenarioEnteros("BAJO", nBajo, semilla + 1);
            ejecutarEscenarioEnteros("MEDIO", nMedio, semilla + 2);
            ejecutarEscenarioEnteros("ALTO", nAlto, semilla + 3);
        } else {
            ejecutarEscenarioString("BAJO", nBajo, semilla + 1);
            ejecutarEscenarioString("MEDIO", nMedio, semilla + 2);
            ejecutarEscenarioString("ALTO", nAlto, semilla + 3);
        }

        sc.close();
    }

    private static void ejecutarEscenarioEnteros(String etiqueta, int n, long semilla) {
        System.out.println("\n===== ESCENARIO " + etiqueta + " | n=" + n + " =====");
        int[] base = generarEnteros(n, semilla);
        System.out.println("Base: " + vistaCorta(base));
        int frecuencia = frecuenciaTraza(n);

        medirMemoriaEnteros("Burbuja simple", base, frecuencia, Programa27MemoriaComparativa::burbujaSimple);
        medirMemoriaEnteros("Burbuja mejorado", base, frecuencia, Programa27MemoriaComparativa::burbujaMejorado);
        medirMemoriaEnteros("Quicksort", base, frecuencia, (arr, tr) -> quickSort(arr, 0, arr.length - 1, tr));
        medirMemoriaEnteros("Shell Sort", base, frecuencia, Programa27MemoriaComparativa::shellSort);
        medirMemoriaEnteros("Seleccion", base, frecuencia, Programa27MemoriaComparativa::seleccion);
    }

    private static void ejecutarEscenarioString(String etiqueta, int n, long semilla) {
        System.out.println("\n===== ESCENARIO " + etiqueta + " | n=" + n + " =====");
        String[] base = generarStrings(n, semilla);
        System.out.println("Base: " + vistaCorta(base));
        int frecuencia = frecuenciaTraza(n);

        medirMemoriaString("Burbuja simple", base, frecuencia, Programa27MemoriaComparativa::burbujaSimple);
        medirMemoriaString("Burbuja mejorado", base, frecuencia, Programa27MemoriaComparativa::burbujaMejorado);
        medirMemoriaString("Quicksort", base, frecuencia, (arr, tr) -> quickSort(arr, 0, arr.length - 1, tr));
        medirMemoriaString("Shell Sort", base, frecuencia, Programa27MemoriaComparativa::shellSort);
        medirMemoriaString("Seleccion", base, frecuencia, Programa27MemoriaComparativa::seleccion);
    }

    private static void medirMemoriaEnteros(String nombre, int[] base, int frecuencia, OrdenadorEnteros algoritmo) {
        int[] copia = Arrays.copyOf(base, base.length);
        Runtime rt = Runtime.getRuntime();

        System.gc();
        long memBase = memoriaUsada(rt);

        TrazaEnteros tr = new TrazaEnteros(nombre, frecuencia, rt, memBase);
        algoritmo.ordenar(copia, tr);

        System.gc();
        long memFin = memoriaUsada(rt);
        long delta = memFin - memBase;

        System.out.printf("RESULTADO %-17s -> delta=%12d bytes | %9.3f KB | pasos=%d | %s%n",
                nombre, delta, delta / 1024.0, tr.pasos, vistaCorta(copia));
    }

    private static void medirMemoriaString(String nombre, String[] base, int frecuencia, OrdenadorString algoritmo) {
        String[] copia = Arrays.copyOf(base, base.length);
        Runtime rt = Runtime.getRuntime();

        System.gc();
        long memBase = memoriaUsada(rt);

        TrazaString tr = new TrazaString(nombre, frecuencia, rt, memBase);
        algoritmo.ordenar(copia, tr);

        System.gc();
        long memFin = memoriaUsada(rt);
        long delta = memFin - memBase;

        System.out.printf("RESULTADO %-17s -> delta=%12d bytes | %9.3f KB | pasos=%d | %s%n",
                nombre, delta, delta / 1024.0, tr.pasos, vistaCorta(copia));
    }

    // ---------------- ENTEROS ----------------
    private static void burbujaSimple(int[] a, TrazaEnteros t) {
        for (int i = 0; i < a.length - 1; i++) {
            for (int j = 0; j < a.length - 1 - i; j++) {
                t.log("comparar " + j + " y " + (j + 1), a);
                if (a[j] > a[j + 1]) {
                    int x = a[j]; a[j] = a[j + 1]; a[j + 1] = x;
                    t.log("intercambio", a);
                }
            }
        }
    }

    private static void burbujaMejorado(int[] a, TrazaEnteros t) {
        for (int i = 0; i < a.length - 1; i++) {
            boolean cambio = false;
            for (int j = 0; j < a.length - 1 - i; j++) {
                t.log("comparar " + j + " y " + (j + 1), a);
                if (a[j] > a[j + 1]) {
                    int x = a[j]; a[j] = a[j + 1]; a[j + 1] = x;
                    cambio = true;
                    t.log("intercambio", a);
                }
            }
            if (!cambio) {
                t.log("corte temprano", a);
                break;
            }
        }
    }

    private static void quickSort(int[] a, int l, int r, TrazaEnteros t) {
        if (l >= r) return;
        int p = particion(a, l, r, t);
        t.log("pivote en " + p, a);
        quickSort(a, l, p - 1, t);
        quickSort(a, p + 1, r, t);
    }

    private static int particion(int[] a, int l, int r, TrazaEnteros t) {
        int piv = a[r], i = l - 1;
        t.log("particion pivote=" + piv, a);
        for (int j = l; j < r; j++) {
            t.log("comparar con pivote", a);
            if (a[j] <= piv) {
                i++;
                int x = a[i]; a[i] = a[j]; a[j] = x;
                t.log("mover <= pivote", a);
            }
        }
        int x = a[i + 1]; a[i + 1] = a[r]; a[r] = x;
        t.log("colocar pivote final", a);
        return i + 1;
    }

    private static void shellSort(int[] a, TrazaEnteros t) {
        for (int gap = a.length / 2; gap > 0; gap /= 2) {
            t.log("gap=" + gap, a);
            for (int i = gap; i < a.length; i++) {
                int tmp = a[i], j = i;
                while (j >= gap && a[j - gap] > tmp) {
                    a[j] = a[j - gap];
                    j -= gap;
                    t.log("desplazar por gap", a);
                }
                a[j] = tmp;
                t.log("insertar por gap", a);
            }
        }
    }

    private static void seleccion(int[] a, TrazaEnteros t) {
        for (int i = 0; i < a.length - 1; i++) {
            int min = i;
            for (int j = i + 1; j < a.length; j++) {
                t.log("buscar minimo", a);
                if (a[j] < a[min]) {
                    min = j;
                    t.log("nuevo minimo=" + min, a);
                }
            }
            if (min != i) {
                int x = a[i]; a[i] = a[min]; a[min] = x;
                t.log("intercambiar con i", a);
            }
        }
    }

    // ---------------- STRING ----------------
    private static void burbujaSimple(String[] a, TrazaString t) {
        for (int i = 0; i < a.length - 1; i++) {
            for (int j = 0; j < a.length - 1 - i; j++) {
                t.log("comparar " + j + " y " + (j + 1), a);
                if (a[j].compareTo(a[j + 1]) > 0) {
                    String x = a[j]; a[j] = a[j + 1]; a[j + 1] = x;
                    t.log("intercambio", a);
                }
            }
        }
    }

    private static void burbujaMejorado(String[] a, TrazaString t) {
        for (int i = 0; i < a.length - 1; i++) {
            boolean cambio = false;
            for (int j = 0; j < a.length - 1 - i; j++) {
                t.log("comparar " + j + " y " + (j + 1), a);
                if (a[j].compareTo(a[j + 1]) > 0) {
                    String x = a[j]; a[j] = a[j + 1]; a[j + 1] = x;
                    cambio = true;
                    t.log("intercambio", a);
                }
            }
            if (!cambio) {
                t.log("corte temprano", a);
                break;
            }
        }
    }

    private static void quickSort(String[] a, int l, int r, TrazaString t) {
        if (l >= r) return;
        int p = particion(a, l, r, t);
        t.log("pivote en " + p, a);
        quickSort(a, l, p - 1, t);
        quickSort(a, p + 1, r, t);
    }

    private static int particion(String[] a, int l, int r, TrazaString t) {
        String piv = a[r];
        int i = l - 1;
        t.log("particion pivote=" + piv, a);
        for (int j = l; j < r; j++) {
            t.log("comparar con pivote", a);
            if (a[j].compareTo(piv) <= 0) {
                i++;
                String x = a[i]; a[i] = a[j]; a[j] = x;
                t.log("mover <= pivote", a);
            }
        }
        String x = a[i + 1]; a[i + 1] = a[r]; a[r] = x;
        t.log("colocar pivote final", a);
        return i + 1;
    }

    private static void shellSort(String[] a, TrazaString t) {
        for (int gap = a.length / 2; gap > 0; gap /= 2) {
            t.log("gap=" + gap, a);
            for (int i = gap; i < a.length; i++) {
                String tmp = a[i];
                int j = i;
                while (j >= gap && a[j - gap].compareTo(tmp) > 0) {
                    a[j] = a[j - gap];
                    j -= gap;
                    t.log("desplazar por gap", a);
                }
                a[j] = tmp;
                t.log("insertar por gap", a);
            }
        }
    }

    private static void seleccion(String[] a, TrazaString t) {
        for (int i = 0; i < a.length - 1; i++) {
            int min = i;
            for (int j = i + 1; j < a.length; j++) {
                t.log("buscar minimo", a);
                if (a[j].compareTo(a[min]) < 0) {
                    min = j;
                    t.log("nuevo minimo=" + min, a);
                }
            }
            if (min != i) {
                String x = a[i]; a[i] = a[min]; a[min] = x;
                t.log("intercambiar con i", a);
            }
        }
    }

    // ---------------- UTILIDADES ----------------
    private static long memoriaUsada(Runtime rt) { return rt.totalMemory() - rt.freeMemory(); }

    private static int[] generarEnteros(int n, long semilla) {
        Random r = new Random(semilla);
        int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = r.nextInt(50_000);
        return a;
    }

    private static String[] generarStrings(int n, long semilla) {
        Random r = new Random(semilla);
        String[] a = new String[n];
        for (int i = 0; i < n; i++) a[i] = "pal" + r.nextInt(50_000);
        return a;
    }

    private static int frecuenciaTraza(int n) {
        if (n <= 20) return 1;
        if (n <= 300) return 40;
        return 1500;
    }

    private static String vistaCorta(int[] a) {
        int lim = Math.min(a.length, 10);
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < lim; i++) {
            if (i > 0) sb.append(", ");
            sb.append(a[i]);
        }
        if (a.length > lim) sb.append(", ...");
        sb.append("]");
        return sb.toString();
    }

    private static String vistaCorta(String[] a) {
        int lim = Math.min(a.length, 10);
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < lim; i++) {
            if (i > 0) sb.append(", ");
            sb.append(a[i]);
        }
        if (a.length > lim) sb.append(", ...");
        sb.append("]");
        return sb.toString();
    }

    static class TrazaEnteros {
        String algoritmo;
        int frecuencia;
        Runtime rt;
        long base;
        long pasos = 0;

        TrazaEnteros(String algoritmo, int frecuencia, Runtime rt, long base) {
            this.algoritmo = algoritmo;
            this.frecuencia = Math.max(1, frecuencia);
            this.rt = rt;
            this.base = base;
        }

        void log(String evento, int[] estado) {
            pasos++;
            if (pasos <= 12 || pasos % frecuencia == 0) {
                long delta = memoriaUsada(rt) - base;
                System.out.println("[" + algoritmo + "] paso " + pasos + " -> " + evento
                        + " | deltaMem=" + delta + " bytes | " + vistaCorta(estado));
            }
        }
    }

    static class TrazaString {
        String algoritmo;
        int frecuencia;
        Runtime rt;
        long base;
        long pasos = 0;

        TrazaString(String algoritmo, int frecuencia, Runtime rt, long base) {
            this.algoritmo = algoritmo;
            this.frecuencia = Math.max(1, frecuencia);
            this.rt = rt;
            this.base = base;
        }

        void log(String evento, String[] estado) {
            pasos++;
            if (pasos <= 12 || pasos % frecuencia == 0) {
                long delta = memoriaUsada(rt) - base;
                System.out.println("[" + algoritmo + "] paso " + pasos + " -> " + evento
                        + " | deltaMem=" + delta + " bytes | " + vistaCorta(estado));
            }
        }
    }

    @FunctionalInterface
    interface OrdenadorEnteros { void ordenar(int[] arreglo, TrazaEnteros traza); }
    @FunctionalInterface
    interface OrdenadorString { void ordenar(String[] arreglo, TrazaString traza); }
}

// ------------------------------
// EJEMPLOS DE EJECUCION (OUTPUT)
// ------------------------------
// Opcion 1 (Enteros):
// Entrada:
//   Opcion tipo = 1
//   bajos=6, medios=20, altos=60, semilla=42
// Salida esperada (resumen):
//   ===== ESCENARIO BAJO | n=6 =====
//   [Burbuja simple] paso 1 -> comparar 0 y 1 | deltaMem=<bytes> | [...]
//   ...
//   RESULTADO Burbuja simple    -> delta=<bytes> bytes | <kb> KB | pasos=<n> | [..ordenado..]
//   RESULTADO Burbuja mejorado  -> ...
//   RESULTADO Quicksort         -> ...
//   RESULTADO Shell Sort        -> ...
//   RESULTADO Seleccion         -> ...
//
// Opcion 2 (String):
// Entrada:
//   Opcion tipo = 2
//   bajos=6, medios=20, altos=60, semilla=42
// Salida esperada (resumen):
//   ===== ESCENARIO BAJO | n=6 =====
//   [Burbuja simple] paso 1 -> comparar 0 y 1 | deltaMem=<bytes> | [pal..., ...]
//   ...
//   RESULTADO Burbuja simple    -> delta=<bytes> bytes | <kb> KB | pasos=<n> | [..ordenado..]
//   RESULTADO Burbuja mejorado  -> ...
//   RESULTADO Quicksort         -> ...
//   RESULTADO Shell Sort        -> ...
//   RESULTADO Seleccion         -> ...

